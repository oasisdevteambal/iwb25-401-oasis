# Supabase Database Schema & Configuration

## Overview

This document contains the complete database schema, configuration, and setup instructions for the Sri Lankan Tax Calculation Application using Supabase as the backend database and storage solution.


## ðŸ“Š Complete Database Schema

### 1. Documents Table

**Purpose**: Central repository for all uploaded tax-related documents and their processing lifecycle management.

**Description**: This table serves as the primary document registry for the Sri Lankan Tax Application. It stores metadata for all uploaded documents (PDFs, Word docs, text files) containing tax legislation, regulations, circulars, and other official tax documents from Sri Lankan authorities. The table tracks the complete document processing pipeline from upload through chunking, text extraction, rule extraction, and final completion. It includes source authority classification (Acts, Gazettes, Regulations, etc.) and ranking for precedence handling during rule conflicts.

**Key Features**:
- Document lifecycle tracking with status progression
- Source authority classification for legal precedence
- Processing performance metrics and error tracking
- File metadata and storage path management
```sql
create table public.documents (
  id text not null,
  filename text not null,
  file_path text not null,
  content_type text not null,
  upload_date timestamp without time zone null default CURRENT_TIMESTAMP,
  processed boolean null default false,
  status text null default 'uploaded'::text,
  total_chunks integer null default 0,
  file_size bigint null,
  document_type text null,
  processing_start_time timestamp without time zone null,
  processing_end_time timestamp without time zone null,
  processing_duration_ms integer null,
  error_message text null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  source_authority text null,
  source_rank integer null,
  constraint documents_pkey primary key (id),
  constraint valid_document_type check (
    (
      document_type = any (
        array[
          'pdf'::text,
          'docx'::text,
          'doc'::text,
          'txt'::text,
          'html'::text,
          'xml'::text,
          'tax_document'::text
        ]
      )
    )
  ),
  constraint valid_source_authority check (
    (
      source_authority = any (
        array[
          'Act'::text,
          'Gazette'::text,
          'Regulation'::text,
          'Circular'::text,
          'Ruling'::text,
          'Guideline'::text,
          'Notice'::text,
          'Other'::text
        ]
      )
    )
  ),
  constraint valid_status check (
    (
      status = any (
        array[
          'uploaded'::text,
          'processing'::text,
          'chunking'::text,
          'extracting'::text,
          'embedded'::text,
          'completed'::text,
          'failed'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_documents_status on public.documents using btree (status) TABLESPACE pg_default;

create index IF not exists idx_documents_processed on public.documents using btree (processed) TABLESPACE pg_default;

create index IF not exists idx_documents_upload_date on public.documents using btree (upload_date) TABLESPACE pg_default;

create index IF not exists idx_documents_document_type on public.documents using btree (document_type) TABLESPACE pg_default;

create index IF not exists idx_documents_source_authority on public.documents using btree (source_authority) TABLESPACE pg_default;

create index IF not exists idx_documents_source_rank on public.documents using btree (source_rank) TABLESPACE pg_default;

create trigger update_documents_updated_at BEFORE
update on documents for EACH row
execute FUNCTION update_updated_at_column ();
```


### 2. Document Chunks Table

**Purpose**: Intelligent document segmentation storage with vector embeddings for semantic search and AI-powered rule extraction.

**Description**: This table stores intelligently segmented pieces of documents created through advanced chunking algorithms. Each chunk represents a coherent section of legal text (paragraphs, tables, definitions, examples) with associated vector embeddings generated by Google's Gemini text-embedding models. The chunks are optimized for semantic search, enabling the application to find relevant tax rules based on natural language queries. The table tracks processing status, relevance scoring, and maintains relationships back to source documents for traceability.

**Key Features**:
- Vector embeddings for semantic similarity search
- Intelligent chunk type classification (paragraph, table, header, etc.)
- Relevance scoring and context keyword extraction
- Sequential ordering within source documents

```sql
create table public.document_chunks (
  id text not null,
  document_id text null,
  chunk_sequence integer not null,
  start_position integer null,
  end_position integer null,
  chunk_text text not null,
  chunk_size integer null,
  token_count integer null,
  chunk_type text null default 'paragraph'::text,
  processing_status text null default 'created'::text,
  relevance_score numeric(5, 4) null,
  context_keywords text[] null,
  embedding public.vector null,
  embedding_model text null default 'text-embedding-004'::text,
  embedding_provider text null default 'google_gemini'::text,
  embedding_generated_at timestamp without time zone null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint document_chunks_pkey primary key (id),
  constraint unique_document_sequence unique (document_id, chunk_sequence),
  constraint document_chunks_document_id_fkey foreign KEY (document_id) references documents (id) on delete CASCADE deferrable initially DEFERRED,
  constraint valid_chunk_type check (
    (
      chunk_type = any (
        array[
          'paragraph'::text,
          'table'::text,
          'header'::text,
          'list'::text,
          'formula'::text,
          'definition'::text,
          'example'::text
        ]
      )
    )
  ),
  constraint valid_processing_status check (
    (
      processing_status = any (
        array[
          'created'::text,
          'scored'::text,
          'validated'::text,
          'embedded'::text,
          'stored'::text,
          'failed'::text
        ]
      )
    )
  ),
  constraint valid_relevance_score check (
    (
      (relevance_score >= 0.0)
      and (relevance_score <= 1.0)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_document_chunks_document_id on public.document_chunks using btree (document_id) TABLESPACE pg_default;

create index IF not exists idx_document_chunks_sequence on public.document_chunks using btree (chunk_sequence) TABLESPACE pg_default;

create index IF not exists idx_document_chunks_processing_status on public.document_chunks using btree (processing_status) TABLESPACE pg_default;

create index IF not exists idx_document_chunks_relevance_score on public.document_chunks using btree (relevance_score) TABLESPACE pg_default;

create index IF not exists idx_document_chunks_embedding_cosine on public.document_chunks using ivfflat (embedding vector_cosine_ops)
with
  (lists = '100') TABLESPACE pg_default;

create trigger update_document_chunks_updated_at BEFORE
update on document_chunks for EACH row
execute FUNCTION update_updated_at_column ();
```

### 3. Tax Rules Table

**Purpose**: Core repository for extracted and aggregated tax calculation rules with semantic search capabilities.

**Description**: This is the heart of the tax calculation engine, storing structured tax rules extracted from legal documents using AI/LLM processing. Each rule represents a specific tax calculation logic, formula, or requirement derived from Sri Lankan tax legislation. The table supports both 'evidence' rules (directly extracted from documents) and 'aggregated' rules (synthesized from multiple sources to resolve conflicts). Rules include calculation formulas, dependent variables, effective date ranges, and validation status. Vector embeddings enable semantic matching for rule retrieval during calculations.

**Key Features**:
- Dual rule types: evidence-based and aggregated
- Calculation formula storage with dependency tracking
- Temporal validity with effective/expiry dates
- Semantic search via vector embeddings
- Validation workflow and conflict analysis metadata

```sql
create table public.tax_rules (
  id text not null,
  rule_type text not null,
  rule_category text null,
  title text not null,
  description text null,
  rule_data jsonb not null,
  embedding public.vector null,
  effective_date date null,
  expiry_date date null,
  document_source_id text null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  chunk_id text null,
  chunk_sequence integer null,
  chunk_confidence numeric(3, 2) null,
  extraction_context text null,
  cross_chunk_refs integer null default 0,
  calculation_formula text null,
  dependent_variables text[] null,
  calculation_order integer null default 0,
  validation_status text null default 'pending'::text,
  source_kind text null default 'evidence'::text,
  constraint tax_rules_pkey primary key (id),
  constraint tax_rules_chunk_id_fkey foreign KEY (chunk_id) references document_chunks (id) on delete set null deferrable initially DEFERRED,
  constraint tax_rules_document_source_id_fkey foreign KEY (document_source_id) references documents (id) on delete set null deferrable initially DEFERRED,
  constraint valid_date_range check (
    (
      (expiry_date is null)
      or (expiry_date >= effective_date)
    )
  ),
  constraint valid_source_kind check (
    (
      source_kind = any (array['evidence'::text, 'aggregated'::text])
    )
  ),
  constraint valid_validation_status check (
    (
      validation_status = any (
        array[
          'pending'::text,
          'validated'::text,
          'failed'::text,
          'deprecated'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_embedding_cosine on public.tax_rules using ivfflat (embedding vector_cosine_ops)
with
  (lists = '100') TABLESPACE pg_default;

create index IF not exists idx_tax_rules_rule_type on public.tax_rules using btree (rule_type) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_effective_date on public.tax_rules using btree (effective_date) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_document_source on public.tax_rules using btree (document_source_id) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_calculation_order on public.tax_rules using btree (calculation_order) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_validation_status on public.tax_rules using btree (validation_status) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_dependent_variables on public.tax_rules using gin (dependent_variables) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_source_kind on public.tax_rules using btree (source_kind) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_rule_data_gin on public.tax_rules using gin (rule_data) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_rule_category on public.tax_rules using btree (rule_category) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_conflict_metadata on public.tax_rules using gin (((rule_data -> 'conflict_analysis'::text))) TABLESPACE pg_default;

create index IF not exists idx_tax_rules_effective_expiry on public.tax_rules using btree (effective_date, expiry_date, rule_category) TABLESPACE pg_default;

create trigger update_tax_rules_updated_at BEFORE
update on tax_rules for EACH row
execute FUNCTION update_updated_at_column ();
```

### 4. Tax Brackets Table

**Purpose**: Detailed storage of progressive tax bracket structures linked to specific tax rules.

**Description**: This table stores the specific tax bracket information that defines progressive tax calculations (income tax, PAYE, etc.). Each bracket represents a tax rate band with minimum/maximum income thresholds, tax rates, and any fixed amounts. The brackets are ordered sequentially and linked to their parent tax rules, enabling accurate progressive tax calculations. This structure supports Sri Lanka's tiered tax system where different income ranges are taxed at different rates.

**Key Features**:
- Progressive tax bracket definition
- Rate and fixed amount combinations
- Sequential ordering for calculation logic
- Tight coupling with parent tax rules

```sql
create table public.tax_brackets (
  id text not null,
  rule_id text null,
  min_income numeric(15, 2) null,
  max_income numeric(15, 2) null,
  rate numeric(5, 4) not null,
  fixed_amount numeric(15, 2) null default 0,
  bracket_order integer not null,
  constraint tax_brackets_pkey primary key (id),
  constraint unique_rule_bracket_order unique (rule_id, bracket_order),
  constraint tax_brackets_rule_id_fkey foreign KEY (rule_id) references tax_rules (id) on delete CASCADE deferrable initially DEFERRED
) TABLESPACE pg_default;
```

### 5. Form Schemas Table

**Purpose**: Dynamic form generation and validation schemas created from extracted tax rules.

**Description**: This table stores dynamically generated form schemas that define the user interface and validation rules for tax calculation forms. Each schema is automatically generated from tax rules and represents a specific calculation type (income tax, VAT, PAYE, etc.). The schemas include field definitions, validation rules, calculation logic, and test cases. The system maintains version control and ensures only one active schema per type, enabling seamless updates to tax forms as legislation changes.

**Key Features**:
- Dynamic schema generation from tax rules
- Built-in calculation and validation rules
- Version control with single active schema per type
- Comprehensive test case storage for validation

```sql
create table public.form_schemas (
  id text not null,
  schema_type text not null,
  version integer not null,
  schema_data jsonb not null,
  is_active boolean null default false,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  calculation_rules jsonb null,
  required_variables text[] null,
  validation_test_cases jsonb null,
  schema_metadata jsonb null,
  constraint form_schemas_pkey primary key (id),
  constraint unique_active_schema_type unique (schema_type, is_active) deferrable initially DEFERRED
) TABLESPACE pg_default;

create index IF not exists idx_form_schemas_calculation_rules on public.form_schemas using gin (calculation_rules) TABLESPACE pg_default;

create index IF not exists idx_form_schemas_required_variables on public.form_schemas using gin (required_variables) TABLESPACE pg_default;
```

### 6. Tax Calculations Table

**Purpose**: Historical record of user tax calculations and results for audit and analysis.

**Description**: This table maintains a historical record of all tax calculations performed by users, storing both input data and calculated results. It supports various Sri Lankan tax types including income tax, VAT, PAYE, withholding tax, NBT, and SSCL. Each calculation record includes the complete input dataset, detailed results, and final tax amounts. This serves as both a user history feature and an audit trail for tax calculations, enabling analysis of calculation patterns and accuracy verification.

**Key Features**:
- Multi-tax-type calculation support
- Complete input/output data preservation
- User-based calculation history
- Audit trail for compliance and verification

```sql
create table public.calculations (
  id text not null,
  user_id text null,
  calculation_type text not null,
  input_data jsonb not null,
  result_data jsonb not null,
  total_tax numeric(15, 2) null,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint calculations_pkey primary key (id),
  constraint valid_calculation_type check (
    (
      calculation_type = any (
        array[
          'income_tax'::text,
          'vat'::text,
          'paye'::text,
          'wht'::text,
          'nbt'::text,
          'sscl'::text,
          'combined'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_calculations_user_date on public.calculations using btree (user_id, created_at desc) TABLESPACE pg_default;

create index IF not exists idx_calculations_type on public.calculations using btree (calculation_type) TABLESPACE pg_default;
```

### 7. Chunk Processing Statistics Table

**Purpose**: Performance monitoring and analytics for document processing operations.

**Description**: This table tracks detailed performance metrics for document chunk processing operations, providing insights into the efficiency and quality of the AI-powered rule extraction pipeline. It monitors API calls to external services (Gemini), rules extraction counts, processing errors, and quality scores. The data supports system optimization, error analysis, and processing time improvements. Quality scores help identify chunks that may need reprocessing or manual review.

**Key Features**:
- Processing performance tracking with timing metrics
- API usage monitoring for cost optimization
- Quality scoring for extraction validation
- Error tracking and retry count management

```sql
create table public.chunk_processing_stats (
  id text not null,
  chunk_id text null,
  processing_start_time timestamp without time zone null,
  processing_end_time timestamp without time zone null,
  gemini_api_calls integer null default 0,
  rules_extracted integer null default 0,
  processing_errors integer null default 0,
  quality_score numeric(3, 2) null,
  retry_count integer null default 0,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint chunk_processing_stats_pkey primary key (id),
  constraint chunk_processing_stats_chunk_id_fkey foreign KEY (chunk_id) references document_chunks (id) on delete CASCADE deferrable initially DEFERRED,
  constraint valid_quality_score check (
    (
      (quality_score >= 0.00)
      and (quality_score <= 1.00)
    )
  )
) TABLESPACE pg_default;
```

### 8. User Management Tables (Optional)

**Purpose**: User authentication, authorization, and profile management for the tax application.

**Description**: This optional table supports user management functionality when implementing authentication and role-based access control. It stores user profiles with email authentication, role-based permissions (admin, user, viewer), and account metadata. The role system enables different access levels - admins can manage documents and rules, users can perform calculations, and viewers have read-only access. This table integrates with Supabase Auth or external authentication providers.

**Key Features**:
- Role-based access control (admin, user, viewer)
- Email-based user identification
- Profile management with timestamps
- Integration ready for Supabase Auth

```sql
create table public.user_profiles (
  id text not null,
  email text null,
  full_name text null,
  role text null default 'user'::text,
  created_at timestamp without time zone null default CURRENT_TIMESTAMP,
  updated_at timestamp without time zone null default CURRENT_TIMESTAMP,
  constraint user_profiles_pkey primary key (id),
  constraint user_profiles_email_key unique (email),
  constraint valid_role check (
    (
      role = any (
        array['admin'::text, 'user'::text, 'viewer'::text]
      )
    )
  )
) TABLESPACE pg_default;

create trigger update_user_profiles_updated_at BEFORE
update on user_profiles for EACH row
execute FUNCTION update_updated_at_column ();
```

### 9. Calculation Audit Table

**Purpose**: Comprehensive audit trail for all tax calculations with performance metrics and rule version tracking.

**Description**: This table provides detailed audit capabilities for tax calculations, recording every calculation performed through the system with complete traceability. It captures the form schema used, input data, results, execution performance, and rule versions active at calculation time. Each calculation is assigned a unique execution ID for correlation with errors or debugging. This supports compliance requirements, performance analysis, and system reliability monitoring.

**Key Features**:
- Complete calculation audit trail with unique execution IDs
- Performance monitoring with execution time tracking
- Rule version tracking for historical accuracy
- User attribution and calculation type classification

```sql
create table public.calculation_audit (
  id uuid not null default gen_random_uuid (),
  schema_id text not null,
  input_data jsonb not null,
  calculation_result jsonb not null,
  execution_time_ms integer null,
  rules_version text null,
  execution_id uuid not null,
  user_id text null,
  calculation_type text not null,
  final_amount numeric(15, 2) null,
  created_at timestamp without time zone null default now(),
  constraint calculation_audit_pkey primary key (id),
  constraint calculation_audit_schema_id_fkey foreign KEY (schema_id) references form_schemas (id),
  constraint valid_execution_time check ((execution_time_ms >= 0)),
  constraint valid_final_amount check ((final_amount >= (0)::numeric))
) TABLESPACE pg_default;

create index IF not exists idx_calculation_audit_schema_id on public.calculation_audit using btree (schema_id) TABLESPACE pg_default;

create index IF not exists idx_calculation_audit_created_at on public.calculation_audit using btree (created_at desc) TABLESPACE pg_default;

create index IF not exists idx_calculation_audit_user_id on public.calculation_audit using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_calculation_audit_type on public.calculation_audit using btree (calculation_type) TABLESPACE pg_default;

create index IF not exists idx_calculation_audit_execution_id on public.calculation_audit using btree (execution_id) TABLESPACE pg_default;
```


### 10. Rule Test Cases Table

**Purpose**: Automated testing framework for validating tax rule accuracy and calculation correctness.

**Description**: This table stores comprehensive test cases for tax rules, enabling automated validation of calculation accuracy. Each test case defines specific input scenarios and expected outputs for tax rules, supporting regression testing when rules are updated or new legislation is implemented. Test cases can be activated/deactivated and include descriptive documentation. This ensures the reliability and accuracy of tax calculations as the rule base evolves.

**Key Features**:
- Automated test case execution for rule validation
- Input/output scenario definition with expected results
- Test case activation control and descriptive documentation
- Regression testing support for rule updates

```sql
create table public.rule_test_cases (
  id uuid not null default gen_random_uuid (),
  rule_id text not null,
  test_name text not null,
  input_data jsonb not null,
  expected_output jsonb not null,
  test_description text null,
  is_active boolean null default true,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  constraint rule_test_cases_pkey primary key (id),
  constraint unique_rule_test_name unique (rule_id, test_name),
  constraint rule_test_cases_rule_id_fkey foreign KEY (rule_id) references tax_rules (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_rule_test_cases_rule_id on public.rule_test_cases using btree (rule_id) TABLESPACE pg_default;

create index IF not exists idx_rule_test_cases_active on public.rule_test_cases using btree (is_active) TABLESPACE pg_default;

create trigger update_rule_test_cases_updated_at BEFORE
update on rule_test_cases for EACH row
execute FUNCTION update_updated_at_column ();
```



### 11. Calculation Errors Table

**Purpose**: Comprehensive error tracking and debugging system for failed tax calculations.

**Description**: This table captures and categorizes all calculation errors that occur during tax processing, providing detailed debugging information and error classification. It tracks various error types from formula parsing errors to database issues, stores complete error context including input data and failure points, and supports retry mechanisms. The system helps identify systematic issues, supports debugging efforts, and tracks resolution status for failed calculations.

**Key Features**:
- Detailed error classification and categorization
- Complete error context preservation with stack traces
- Retry mechanism tracking and resolution status
- Error correlation with execution IDs for debugging

```sql
create table public.calculation_errors (
  id uuid not null default gen_random_uuid (),
  execution_id uuid not null,
  schema_id text null,
  error_type text not null,
  error_message text not null,
  error_stack text null,
  input_data jsonb null,
  failed_step text null,
  retry_count integer null default 0,
  resolved boolean null default false,
  created_at timestamp without time zone null default now(),
  constraint calculation_errors_pkey primary key (id),
  constraint calculation_errors_schema_id_fkey foreign KEY (schema_id) references form_schemas (id),
  constraint valid_error_type check (
    (
      error_type = any (
        array[
          'formula_parse_error'::text,
          'variable_missing'::text,
          'calculation_overflow'::text,
          'rule_validation_failed'::text,
          'database_error'::text,
          'unknown_error'::text
        ]
      )
    )
  ),
  constraint valid_retry_count check ((retry_count >= 0))
) TABLESPACE pg_default;

create index IF not exists idx_calculation_errors_execution_id on public.calculation_errors using btree (execution_id) TABLESPACE pg_default;

create index IF not exists idx_calculation_errors_schema_id on public.calculation_errors using btree (schema_id) TABLESPACE pg_default;

create index IF not exists idx_calculation_errors_type on public.calculation_errors using btree (error_type) TABLESPACE pg_default;

create index IF not exists idx_calculation_errors_resolved on public.calculation_errors using btree (resolved) TABLESPACE pg_default;

create index IF not exists idx_calculation_errors_created_at on public.calculation_errors using btree (created_at desc) TABLESPACE pg_default;
```



### 12. Form Field Mappings Table

**Purpose**: Field mapping and data transformation system for form schema evolution and migration.

**Description**: This table manages field mappings between different versions of form schemas, enabling seamless data migration when tax forms evolve due to legislative changes. It supports various mapping types including direct field copying, renaming, splitting, combining, and default value assignment. The system ensures that historical data remains accessible and can be migrated to new form structures, maintaining data continuity as tax regulations change.

**Key Features**:
- Schema version migration and field transformation
- Multiple mapping types (direct, rename, split, combine, default, remove)
- Historical data preservation during schema evolution
- Activation control for mapping rules

```sql
create table public.form_field_mappings (
  id uuid not null default gen_random_uuid (),
  from_schema_id text not null,
  to_schema_id text not null,
  from_field_name text not null,
  to_field_name text not null,
  mapping_type text not null,
  mapping_rules jsonb null,
  is_active boolean null default true,
  created_at timestamp without time zone null default now(),
  constraint form_field_mappings_pkey primary key (id),
  constraint unique_field_mapping unique (from_schema_id, to_schema_id, from_field_name),
  constraint form_field_mappings_from_schema_id_fkey foreign KEY (from_schema_id) references form_schemas (id),
  constraint form_field_mappings_to_schema_id_fkey foreign KEY (to_schema_id) references form_schemas (id),
  constraint valid_mapping_type check (
    (
      mapping_type = any (
        array[
          'direct'::text,
          'rename'::text,
          'split'::text,
          'combine'::text,
          'default'::text,
          'remove'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_form_field_mappings_from_schema on public.form_field_mappings using btree (from_schema_id) TABLESPACE pg_default;

create index IF not exists idx_form_field_mappings_to_schema on public.form_field_mappings using btree (to_schema_id) TABLESPACE pg_default;

create index IF not exists idx_form_field_mappings_type on public.form_field_mappings using btree (mapping_type) TABLESPACE pg_default;

create index IF not exists idx_form_field_mappings_active on public.form_field_mappings using btree (is_active) TABLESPACE pg_default;
```


### 13. System Config Table

**Purpose**: Centralized configuration management for tax calculation engine settings and business rules.

**Description**: This table stores system-wide configuration settings that control the behavior of the tax calculation engine. It manages calculation engine parameters, rounding rules, tax constants (like standard deduction amounts), validation rules, and API settings. The configuration system supports different config types with JSON-based value storage, enabling flexible parameter management without code changes. Settings can be activated/deactivated for testing or gradual rollout.

**Key Features**:
- Centralized configuration management with JSON value storage
- Configuration type categorization (calculation, rounding, constants, validation, API)
- Activation control for testing and gradual rollout
- Flexible parameter management without code deployment

```sql
create table public.system_config (
  key text not null,
  value jsonb not null,
  description text null,
  config_type text not null,
  is_active boolean null default true,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  constraint system_config_pkey primary key (key),
  constraint valid_config_type check (
    (
      config_type = any (
        array[
          'calculation_engine'::text,
          'rounding_rules'::text,
          'tax_constants'::text,
          'validation_rules'::text,
          'api_settings'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_system_config_type on public.system_config using btree (config_type) TABLESPACE pg_default;

create index IF not exists idx_system_config_active on public.system_config using btree (is_active) TABLESPACE pg_default;

create trigger update_system_config_updated_at BEFORE
update on system_config for EACH row
execute FUNCTION update_updated_at_column ();
```


### 14. Active Calculation Schemas View

**Purpose**: Real-time dashboard view of currently active form schemas with usage analytics.

**Description**: This view provides a comprehensive overview of all currently active form schemas along with their usage statistics. It combines form schema data with calculation audit information to show which schemas are being used most frequently, when they were last used, and their overall calculation volume. This view supports administrators in monitoring form usage patterns, identifying popular calculation types, and making decisions about schema optimization or retirement.

**Key Features**:
- Real-time view of active schemas with usage metrics
- Calculation count and last usage tracking
- Administrative dashboard support for schema management
- Usage pattern analysis for optimization decisions

```sql
create view public.active_calculation_schemas as
select
  fs.id,
  fs.schema_type,
  fs.version,
  fs.schema_data,
  fs.calculation_rules,
  fs.required_variables,
  fs.created_at,
  count(ca.id) as calculation_count,
  max(ca.created_at) as last_used_at
from
  form_schemas fs
  left join calculation_audit ca on fs.id = ca.schema_id
where
  fs.is_active = true
group by
  fs.id,
  fs.schema_type,
  fs.version,
  fs.schema_data,
  fs.calculation_rules,
  fs.required_variables,
  fs.created_at;
```

### 15. Calculation Stats View

**Purpose**: Aggregated analytics and performance metrics for tax calculations across all schemas and types.

**Description**: This view provides aggregated statistical analysis of tax calculations, grouping data by schema, calculation type, and date. It calculates performance metrics including average execution times, calculation volume trends, and tax amount ranges (min, max, average). This view supports business intelligence, performance monitoring, and system optimization by providing insights into calculation patterns, popular tax types, and processing efficiency over time.

**Key Features**:
- Aggregated calculation analytics with statistical summaries
- Performance metrics including execution time analysis
- Trend analysis by date, schema, and calculation type
- Business intelligence support for system optimization

```sql
create view public.calculation_stats as
select
  schema_id,
  calculation_type,
  count(*) as total_calculations,
  avg(execution_time_ms) as avg_execution_time,
  min(final_amount) as min_amount,
  max(final_amount) as max_amount,
  avg(final_amount) as avg_amount,
  date_trunc('day'::text, created_at) as calculation_date
from
  calculation_audit
group by
  schema_id,
  calculation_type,
  (date_trunc('day'::text, created_at));
```

### 16. Aggregated Rule Sources Table

**Purpose**: Traceability system linking aggregated tax rules back to their source evidence rules with precedence weighting.

**Description**: This table maintains the relationship between aggregated rules (synthesized from multiple sources) and their underlying evidence rules (directly extracted from documents). When conflicts arise between different sources of tax information, the system creates aggregated rules that resolve these conflicts. This table tracks which evidence rules contributed to each aggregated rule, the reasoning for precedence decisions, and weighting factors. This provides complete audit trails for rule aggregation decisions and enables transparency in conflict resolution.

**Key Features**:
- Complete traceability from aggregated rules to source evidence
- Precedence reasoning and weighting documentation
- Conflict resolution audit trail and transparency
- Support for legal precedence and authority ranking

```sql
create table public.aggregated_rule_sources (
  id uuid not null default gen_random_uuid (),
  aggregated_rule_id text not null,
  evidence_rule_id text not null,
  precedence_reason text null,
  weight numeric(6, 3) null,
  created_at timestamp without time zone null default now(),
  constraint aggregated_rule_sources_pkey primary key (id),
  constraint aggregated_rule_sources_unique unique (aggregated_rule_id, evidence_rule_id),
  constraint aggregated_rule_sources_aggregated_fk foreign KEY (aggregated_rule_id) references tax_rules (id) on delete CASCADE deferrable initially DEFERRED,
  constraint aggregated_rule_sources_evidence_fk foreign KEY (evidence_rule_id) references tax_rules (id) on delete CASCADE deferrable initially DEFERRED
) TABLESPACE pg_default;

create index IF not exists idx_agg_sources_aggregated on public.aggregated_rule_sources using btree (aggregated_rule_id) TABLESPACE pg_default;

create index IF not exists idx_agg_sources_evidence on public.aggregated_rule_sources using btree (evidence_rule_id) TABLESPACE pg_default;
```

### 17. Aggregation Runs Table

**Purpose**: Execution tracking and management for automated rule aggregation and conflict resolution processes.

**Description**: This table tracks batch operations that aggregate tax rules from multiple sources to resolve conflicts and create unified calculation rules. Each aggregation run processes evidence rules for a specific tax type and target date, attempting to synthesize coherent calculation logic from potentially conflicting sources. The table tracks input/output counts, conflict detection, execution status, and detailed operation results. This supports the automated rule consolidation process that ensures the system has consistent, conflict-free tax calculation rules.

**Key Features**:
- Batch processing tracking for rule aggregation operations
- Conflict detection and resolution metrics
- Input/output rule counting and success tracking
- Detailed operation logging with status management

```sql
create table public.aggregation_runs (
  id uuid not null default gen_random_uuid (),
  tax_type text not null,
  target_date date not null,
  inputs_count integer not null default 0,
  outputs_count integer not null default 0,
  conflicts_count integer not null default 0,
  status text not null default 'completed'::text,
  details jsonb null,
  started_at timestamp without time zone null default now(),
  finished_at timestamp without time zone null,
  constraint aggregation_runs_pkey primary key (id),
  constraint valid_aggregation_status check (
    (
      status = any (
        array[
          'queued'::text,
          'running'::text,
          'completed'::text,
          'failed'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_aggregation_runs_lookup on public.aggregation_runs using btree (tax_type, target_date desc) TABLESPACE pg_default;

create index IF not exists idx_aggregation_runs_status on public.aggregation_runs using btree (status) TABLESPACE pg_default;
```


### 18. Rule Conflicts Table

**Purpose**: Conflict detection, tracking, and resolution management for contradictory tax rules from different sources.

**Description**: This table identifies and tracks conflicts that arise when different authoritative sources provide contradictory tax rules. Conflicts can occur in formula expressions, bracket structures, field types, variable sets, or effective date overlaps. Each conflict is categorized by type, linked to the relevant aggregated rule, and tracks resolution status and methods. The system supports manual review workflows where tax experts can examine conflicts and approve resolution strategies, ensuring accurate and legally sound tax calculations.

**Key Features**:
- Comprehensive conflict detection across multiple rule aspects
- Conflict categorization and resolution tracking
- Manual review workflow support for expert validation
- Resolution method documentation and audit trail

```sql
create table public.rule_conflicts (
  id uuid not null default gen_random_uuid (),
  tax_type text not null,
  target_date date not null,
  aspect text not null,
  status text not null default 'open'::text,
  details jsonb null,
  created_at timestamp without time zone null default now(),
  resolved_at timestamp without time zone null,
  aggregated_rule_id text null,
  field_name text null,
  conflict_type text null,
  description text null,
  resolution_method text null,
  constraint rule_conflicts_pkey primary key (id),
  constraint rule_conflicts_aggregated_rule_id_fkey foreign KEY (aggregated_rule_id) references tax_rules (id) on delete CASCADE,
  constraint valid_conflict_status check (
    (
      status = any (
        array[
          'open'::text,
          'under_review'::text,
          'resolved'::text,
          'dismissed'::text
        ]
      )
    )
  ),
  constraint valid_conflict_type check (
    (
      conflict_type = any (
        array[
          'formula_expression_mismatch'::text,
          'bracket_structure_mismatch'::text,
          'field_type_mismatch'::text,
          'variable_set_mismatch'::text,
          'overlapping_effective_periods'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_rule_conflicts_lookup on public.rule_conflicts using btree (tax_type, target_date desc) TABLESPACE pg_default;

create index IF not exists idx_rule_conflicts_status on public.rule_conflicts using btree (status) TABLESPACE pg_default;

create index IF not exists idx_rule_conflicts_aggregated_rule on public.rule_conflicts using btree (aggregated_rule_id) TABLESPACE pg_default;

create index IF not exists idx_rule_conflicts_type_field on public.rule_conflicts using btree (conflict_type, field_name) TABLESPACE pg_default;
```


### 19. Canonical Variables Table

**Purpose**: Standardized variable definition and normalization system for consistent tax calculations across all rules.

**Description**: This table establishes a canonical vocabulary of tax calculation variables used throughout the system. It standardizes variable names, data types, units, and descriptions to ensure consistency across all tax rules and forms. The system supports variable versioning and deprecation, enabling evolution of the tax vocabulary over time. Categories group related variables (income, deductions, rates, etc.), and the canonical variables serve as the foundation for form generation, rule validation, and calculation consistency.

**Key Features**:
- Standardized tax vocabulary with canonical variable definitions
- Data type validation and unit standardization
- Variable versioning and deprecation management
- Category-based organization for better variable management


```sql
create table public.canonical_variables (
  id uuid not null default gen_random_uuid (),
  key text not null,
  label text not null,
  description text null,
  data_type text not null,
  unit text null,
  category text null,
  version integer not null default 1,
  is_active boolean not null default true,
  deprecation_info jsonb null,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  title text null,
  constraint canonical_variables_pkey primary key (id),
  constraint canonical_variables_key_uk unique (key),
  constraint canonical_variables_key_unique unique (key),
  constraint canonical_variables_valid_type check (
    (
      data_type = any (
        array[
          'string'::text,
          'number'::text,
          'integer'::text,
          'boolean'::text,
          'date'::text,
          'currency'::text,
          'percent'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_canonical_variables_category on public.canonical_variables using btree (category) TABLESPACE pg_default;

create index IF not exists idx_canonical_variables_active on public.canonical_variables using btree (is_active) TABLESPACE pg_default;

create trigger update_canonical_variables_updated_at BEFORE
update on canonical_variables for EACH row
execute FUNCTION update_updated_at_column ();
```

### 20. Canonical Variable Synonyms Table

**Purpose**: AI-powered variable name mapping and normalization system for handling diverse terminology in tax documents.

**Description**: This table manages the mapping between various terms found in tax documents and standardized canonical variables. Since different tax documents may use different terminology for the same concept (e.g., "gross income," "total earnings," "annual income"), this system uses AI/LLM processing to identify synonyms and propose mappings to canonical variables. Each proposed synonym includes confidence scores and requires approval workflows to ensure accuracy. This enables the system to handle diverse vocabulary while maintaining calculation consistency.

**Key Features**:
- AI-powered synonym detection and mapping proposals
- Confidence scoring for mapping quality assessment
- Approval workflow for human validation of mappings
- Normalization support for diverse document terminology


```sql
create table public.canonical_variable_synonyms (
  id uuid not null default gen_random_uuid (),
  variable_id uuid null,
  term text not null,
  normalized_term text not null,
  source text not null default 'llm'::text,
  confidence numeric(3, 2) null,
  status text not null default 'pending'::text,
  created_at timestamp without time zone null default now(),
  decided_at timestamp without time zone null,
  decided_by text null,
  constraint canonical_variable_synonyms_pkey primary key (id),
  constraint canonical_variable_synonyms_variable_id_fkey foreign KEY (variable_id) references canonical_variables (id) on delete set null,
  constraint canonical_variable_synonyms_status check (
    (
      status = any (
        array[
          'pending'::text,
          'approved'::text,
          'rejected'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create unique INDEX IF not exists uq_cvs_normalized_term on public.canonical_variable_synonyms using btree (normalized_term) TABLESPACE pg_default;

create index IF not exists idx_cvs_variable_id on public.canonical_variable_synonyms using btree (variable_id) TABLESPACE pg_default;

create index IF not exists idx_cvs_status on public.canonical_variable_synonyms using btree (status) TABLESPACE pg_default;
```

### 21. LLM Extraction Batches Table

**Purpose**: Batch processing management for AI-powered variable extraction from tax documents.

**Description**: This table manages batch operations where Large Language Models (LLMs) analyze tax documents to identify and extract variable definitions and relationships. Each batch processes a source document for a specific tax type and target date, using versioned extraction tools. The system tracks the number of variable proposals generated, approved, and rejected through human review processes. This supports the semi-automated expansion of the canonical variable vocabulary based on new tax legislation and documents.

**Key Features**:
- Batch management for LLM-powered variable extraction
- Proposal tracking with approval/rejection metrics
- Tool version tracking for extraction consistency
- Source document correlation for traceability


```sql
create table public.llm_extraction_batches (
  id uuid not null default gen_random_uuid (),
  source_document_id text null,
  tax_type text not null,
  target_date date null,
  tool_version text null,
  status text not null default 'pending'::text,
  proposal_count integer not null default 0,
  approved_count integer not null default 0,
  rejected_count integer not null default 0,
  details jsonb null,
  created_at timestamp without time zone null default now(),
  completed_at timestamp without time zone null,
  constraint llm_extraction_batches_pkey primary key (id),
  constraint llm_extraction_batches_source_document_id_fkey foreign KEY (source_document_id) references documents (id) on delete set null,
  constraint llm_extraction_batches_status check (
    (
      status = any (
        array[
          'pending'::text,
          'completed'::text,
          'failed'::text,
          'discarded'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_llm_batches_lookup on public.llm_extraction_batches using btree (tax_type, target_date desc) TABLESPACE pg_default;

create index IF not exists idx_llm_batches_status on public.llm_extraction_batches using btree (status) TABLESPACE pg_default;
```

### 22. LLM Extraction Proposals Table

**Purpose**: Individual variable extraction proposals from AI analysis requiring human review and validation.

**Description**: This table stores individual variable extraction proposals generated by LLM analysis of tax documents. Each proposal represents a term or concept identified in a document chunk that the AI suggests should be mapped to a canonical variable. Proposals include context excerpts, suggested variable keys, confidence scores, and metadata. Human reviewers can approve, reject, or map proposals to existing variables, creating a collaborative human-AI workflow for expanding the tax vocabulary while maintaining quality and accuracy.

**Key Features**:
- Individual LLM variable proposals with context and confidence
- Human review workflow with approval/rejection/mapping options
- Context preservation for informed decision making
- Confidence-based prioritization for review efficiency


```sql
create table public.llm_extraction_proposals (
  id uuid not null default gen_random_uuid (),
  batch_id uuid not null,
  term text not null,
  context_excerpt text null,
  chunk_id text null,
  suggested_variable_key text null,
  suggested_metadata jsonb null,
  confidence numeric(3, 2) null,
  status text not null default 'pending'::text,
  mapped_variable_id uuid null,
  notes text null,
  created_at timestamp without time zone null default now(),
  decided_at timestamp without time zone null,
  decided_by text null,
  constraint llm_extraction_proposals_pkey primary key (id),
  constraint llm_extraction_proposals_batch_id_fkey foreign KEY (batch_id) references llm_extraction_batches (id) on delete CASCADE,
  constraint llm_extraction_proposals_chunk_id_fkey foreign KEY (chunk_id) references document_chunks (id) on delete set null,
  constraint llm_extraction_proposals_mapped_variable_id_fkey foreign KEY (mapped_variable_id) references canonical_variables (id) on delete set null,
  constraint llm_extraction_proposals_status check (
    (
      status = any (
        array[
          'pending'::text,
          'approved'::text,
          'rejected'::text,
          'mapped'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_llm_proposals_batch on public.llm_extraction_proposals using btree (batch_id) TABLESPACE pg_default;

create index IF not exists idx_llm_proposals_status on public.llm_extraction_proposals using btree (status) TABLESPACE pg_default;

create index IF not exists idx_llm_proposals_mapped on public.llm_extraction_proposals using btree (mapped_variable_id) TABLESPACE pg_default;

create index IF not exists idx_llm_proposals_chunk on public.llm_extraction_proposals using btree (chunk_id) TABLESPACE pg_default;

create index IF not exists idx_llm_proposals_metadata_gin on public.llm_extraction_proposals using gin (suggested_metadata) TABLESPACE pg_default;
```

### 23. Rule Field Metadata Table

**Purpose**: Detailed field definition and validation metadata for tax rule form generation and user interface creation.

**Description**: This table stores comprehensive metadata for each field used in tax rules, defining how canonical variables should be presented and validated in user interfaces. It includes field labels, help text, data types, validation constraints (min/max values, enum options), and UI organization information (grouping, ordering). The metadata supports both manual configuration and AI-proposed field definitions, enabling dynamic form generation that creates appropriate user interfaces for each tax calculation type.

**Key Features**:
- Comprehensive field metadata for dynamic form generation
- Validation constraint definition (ranges, enums, required fields)
- UI organization metadata (grouping, ordering, help text)
- Support for manual and AI-proposed field definitions


```sql
create table public.rule_field_metadata (
  id uuid not null default gen_random_uuid (),
  rule_id text not null,
  variable_id uuid not null,
  field_key text not null,
  label text null,
  help_text text null,
  data_type text not null,
  unit text null,
  required boolean not null default false,
  min_value numeric(20, 4) null,
  max_value numeric(20, 4) null,
  enum_options text[] null,
  ui_group text null,
  ui_order integer null default 0,
  effective_date date null,
  status text not null default 'validated'::text,
  source_kind text not null default 'manual'::text,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  constraint rule_field_metadata_pkey primary key (id),
  constraint rule_field_metadata_unique unique (rule_id, variable_id),
  constraint rule_field_metadata_rule_id_fkey foreign KEY (rule_id) references tax_rules (id) on delete CASCADE,
  constraint rule_field_metadata_variable_id_fkey foreign KEY (variable_id) references canonical_variables (id) on delete RESTRICT,
  constraint rule_field_metadata_status check (
    (
      status = any (
        array[
          'pending'::text,
          'validated'::text,
          'deprecated'::text
        ]
      )
    )
  ),
  constraint rule_field_metadata_source_kind check (
    (
      source_kind = any (
        array[
          'manual'::text,
          'llm_proposed'::text,
          'aggregated'::text,
          'inferred'::text
        ]
      )
    )
  ),
  constraint rule_field_metadata_valid_type check (
    (
      data_type = any (
        array[
          'string'::text,
          'number'::text,
          'integer'::text,
          'boolean'::text,
          'date'::text,
          'currency'::text,
          'percent'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_rfm_rule_id on public.rule_field_metadata using btree (rule_id) TABLESPACE pg_default;

create index IF not exists idx_rfm_variable_id on public.rule_field_metadata using btree (variable_id) TABLESPACE pg_default;

create index IF not exists idx_rfm_status on public.rule_field_metadata using btree (status) TABLESPACE pg_default;

create trigger update_rule_field_metadata_updated_at BEFORE
update on rule_field_metadata for EACH row
execute FUNCTION update_updated_at_column ();
```

### 24. Rule Formulas Table

**Purpose**: Mathematical expression storage and management for tax calculation logic within rules.

**Description**: This table stores the actual calculation formulas and mathematical expressions that implement tax rules. Each formula is linked to a specific tax rule and defines a calculation step with its mathematical expression, output variable, and execution order. The system supports complex multi-step calculations where formulas build upon each other in sequence. Formula validation ensures mathematical correctness and variable consistency, while status tracking manages the formula lifecycle through validation and potential deprecation.

**Key Features**:
- Mathematical expression storage with calculation ordering
- Multi-step calculation support with formula sequencing
- Output variable tracking for calculation flow
- Formula validation and lifecycle management


```sql
create table public.rule_formulas (
  id uuid not null default gen_random_uuid (),
  rule_id text not null,
  expression text not null,
  output_variable_id uuid null,
  calculation_order integer not null default 0,
  status text not null default 'validated'::text,
  notes text null,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  constraint rule_formulas_pkey primary key (id),
  constraint rule_formulas_output_variable_id_fkey foreign KEY (output_variable_id) references canonical_variables (id) on delete set null,
  constraint rule_formulas_rule_id_fkey foreign KEY (rule_id) references tax_rules (id) on delete CASCADE,
  constraint rule_formulas_status check (
    (
      status = any (
        array[
          'pending'::text,
          'validated'::text,
          'deprecated'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_rule_formulas_rule on public.rule_formulas using btree (rule_id, calculation_order) TABLESPACE pg_default;

create index IF not exists idx_rule_formulas_status on public.rule_formulas using btree (status) TABLESPACE pg_default;

create trigger update_rule_formulas_updated_at BEFORE
update on rule_formulas for EACH row
execute FUNCTION update_updated_at_column ();
```


### 25. Preflight Runs Table

**Purpose**: System readiness validation and blocker identification before rule aggregation operations.

**Description**: This table tracks preflight validation runs that verify system readiness before executing rule aggregation operations. Preflight checks analyze available evidence rules, existing aggregated rules, and identify any blocking conditions that would prevent successful aggregation. The system ensures data quality and completeness before attempting complex rule synthesis operations, preventing failures and maintaining system reliability. Blocker information helps administrators address issues before running expensive aggregation processes.

**Key Features**:
- Pre-aggregation system readiness validation
- Rule count verification and availability checking
- Blocker identification and prevention of failed operations
- System reliability and data quality assurance


```sql
create table public.preflight_runs (
  id uuid not null default gen_random_uuid (),
  tax_type text not null,
  target_date date not null,
  evidence_rules_count integer not null default 0,
  aggregated_rules_count integer not null default 0,
  blockers jsonb null,
  status text not null default 'ok'::text,
  created_at timestamp without time zone null default now(),
  constraint preflight_runs_pkey primary key (id),
  constraint preflight_runs_status check (
    (status = any (array['ok'::text, 'blocked'::text]))
  )
) TABLESPACE pg_default;

create index IF not exists idx_preflight_runs_lookup on public.preflight_runs using btree (tax_type, target_date desc) TABLESPACE pg_default;
```


### 26. Conflict Analysis Report View

**Purpose**: Comprehensive reporting dashboard for rule conflict analysis and resolution tracking across aggregation operations.

**Description**: This view provides a comprehensive analytical dashboard for understanding rule conflicts across the system. It combines data from aggregation runs and rule conflicts to show conflict patterns, resolution methods, and aggregation success rates. The view helps administrators and tax experts understand where conflicts commonly occur, which resolution methods are most effective, and how the system performs in handling contradictory tax rules from different authoritative sources. This supports continuous improvement of the conflict resolution processes.

**Key Features**:
- Comprehensive conflict analysis dashboard and reporting
- Resolution method effectiveness tracking
- Aggregation operation success rate monitoring
- Administrative insights for system improvement and optimization

```sql
create view public.conflict_analysis_report as
select
  ar.tax_type,
  ar.target_date,
  ar.conflicts_count,
  ar.status as aggregation_status,
  count(rc.id) as stored_conflicts,
  array_agg(distinct rc.conflict_type) as conflict_types,
  array_agg(distinct rc.resolution_method) as resolution_methods,
  ar.started_at,
  ar.finished_at
from
  aggregation_runs ar
  left join rule_conflicts rc on (ar.details ->> 'aggregatedRuleId'::text) = rc.aggregated_rule_id
where
  ar.conflicts_count > 0
group by
  ar.id,
  ar.tax_type,
  ar.target_date,
  ar.conflicts_count,
  ar.status,
  ar.started_at,
  ar.finished_at;
```